package emitter

import (
	"bytes"
	"fmt"
	"sort"
	"strings"
	"text/template"

	"github.com/borderlesshq/restgen/internal/config"
	"github.com/borderlesshq/restgen/internal/schema"
)

// TypesEmitter generates model types files.
type TypesEmitter struct {
	cfg *config.Config
}

// NewTypesEmitter creates a new types emitter.
func NewTypesEmitter(cfg *config.Config) *TypesEmitter {
	return &TypesEmitter{cfg: cfg}
}

// Emit generates the types file content for a schema.
func (e *TypesEmitter) Emit(s *schema.Schema) (string, error) {
	data := e.buildTemplateData(s)

	tmpl, err := template.New("types").Parse(typesTemplate)
	if err != nil {
		return "", fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("executing template: %w", err)
	}

	return buf.String(), nil
}

type typesTemplateData struct {
	Package string
	Imports []string
	Types   []typeDefData
	Inputs  []typeDefData
}

type typeDefData struct {
	Name   string
	Fields []fieldData
}

type fieldData struct {
	Name    string
	GoName  string
	GoType  string
	JSONTag string
}

func (e *TypesEmitter) buildTemplateData(s *schema.Schema) *typesTemplateData {
	// Derive package name from models path
	pkg := "models"
	if s.Models != "" {
		parts := strings.Split(s.Models, "/")
		pkg = parts[len(parts)-1]
	}

	// Build include aliases map (namespace -> import path)
	includeImports := make(map[string]string)
	for _, inc := range s.Includes {
		if inc.Models != "" {
			includeImports[inc.Namespace] = inc.Models
		}
	}

	// Collect required imports
	importsMap := make(map[string]bool)

	collectFieldImports := func(fields []schema.Field) {
		for _, f := range fields {
			// Check for scalar imports (e.g., time.Time)
			if imp := e.importForType(f.Type); imp != "" {
				importsMap[imp] = true
			}
			// Check for namespaced type imports
			ns, _ := schema.ParseTypeRef(f.Type)
			if ns != "" {
				if impPath, ok := includeImports[ns]; ok {
					importsMap[impPath] = true
				}
			}
		}
	}

	for _, t := range s.Types {
		collectFieldImports(t.Fields)
	}
	for _, t := range s.Inputs {
		collectFieldImports(t.Fields)
	}

	var imports []string
	for imp := range importsMap {
		imports = append(imports, imp)
	}
	sort.Strings(imports)

	// Build type definitions
	var types []typeDefData
	for _, t := range s.Types {
		types = append(types, e.buildTypeDef(t.Name, t.Fields))
	}

	var inputs []typeDefData
	for _, t := range s.Inputs {
		inputs = append(inputs, e.buildTypeDef(t.Name, t.Fields))
	}

	return &typesTemplateData{
		Package: pkg,
		Imports: imports,
		Types:   types,
		Inputs:  inputs,
	}
}

func (e *TypesEmitter) buildTypeDef(name string, fields []schema.Field) typeDefData {
	td := typeDefData{Name: name}

	for _, f := range fields {
		goType := e.resolveGoType(f.Type, f.Required, f.IsList)

		// Use field name as-is for JSON tag
		jsonTag := f.Name
		if !f.Required && !f.IsList {
			jsonTag += ",omitempty"
		}

		td.Fields = append(td.Fields, fieldData{
			Name:    f.Name,
			GoName:  toExportedName(f.Name),
			GoType:  goType,
			JSONTag: jsonTag,
		})
	}

	return td
}

// resolveGoType converts an SDL type to a Go type, handling namespaced types.
func (e *TypesEmitter) resolveGoType(typeRef string, required bool, isList bool) string {
	ns, typeName := schema.ParseTypeRef(typeRef)

	var goType string
	if ns != "" {
		// Namespaced type: geo.Location -> geo.Location (package alias matches namespace)
		goType = ns + "." + typeName
	} else if mapped, ok := e.cfg.Scalars[typeName]; ok {
		// Scalar type
		goType = mapped
	} else {
		// Local type (same package, no prefix needed)
		goType = typeName
	}

	if isList {
		goType = "[]" + goType
	}

	if !required && !isList {
		goType = "*" + goType
	}

	return goType
}

func (e *TypesEmitter) importForType(typeName string) string {
	goType, ok := e.cfg.Scalars[typeName]
	if !ok {
		return ""
	}

	switch goType {
	case "time.Time":
		return "time"
	default:
		// Check for package-qualified types like "decimal.Decimal"
		if strings.Contains(goType, ".") {
			parts := strings.Split(goType, ".")
			if len(parts) == 2 {
				// This is simplified - real impl would need full import path
				return ""
			}
		}
		return ""
	}
}

// toExportedName converts camelCase to PascalCase.
func toExportedName(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

var typesTemplate = `// Code generated by restgen. DO NOT EDIT.

package {{.Package}}
{{if .Imports}}

import (
{{- range .Imports}}
	"{{.}}"
{{- end}}
)
{{end}}
{{range .Types}}
type {{.Name}} struct {
{{- range .Fields}}
	{{.GoName}} {{.GoType}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{end}}
{{- range .Inputs}}
type {{.Name}} struct {
{{- range .Fields}}
	{{.GoName}} {{.GoType}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{end}}`
